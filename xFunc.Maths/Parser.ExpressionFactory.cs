// Copyright (c) Dmytro Kyshchenko. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Diagnostics;
using System.Runtime.CompilerServices;
using static xFunc.Maths.Tokenization.TokenKind;

namespace xFunc.Maths;

/// <summary>
/// The parser for mathematical expressions.
/// </summary>
public partial class Parser
{
    // This function is automatically generated by xFunc.SourceGenerators.
    // private IExpression CreateFunction(in Token token, ImmutableArray<IExpression> arguments)
    private IExpression CreateBinaryAssign(
        in Token token,
        Variable first,
        IExpression second)
    {
        if (token.Is(AddAssignOperator))
            return new AddAssign(first, second);
        if (token.Is(SubAssignOperator))
            return new SubAssign(first, second);
        if (token.Is(MulAssignOperator))
            return new MulAssign(first, second);
        if (token.Is(DivAssignOperator))
            return new DivAssign(first, second);
        if (token.Is(LeftShiftAssignOperator))
            return new LeftShiftAssign(first, second);

        Debug.Assert(token.Is(RightShiftAssignOperator), "Only '+=', '-=', '*=', '/=', '<<=', '>>=' operators are allowed here.");

        return new RightShiftAssign(first, second);
    }

    private IExpression CreateBitwiseOperator(
        in Token token,
        IExpression first,
        IExpression second)
    {
        if (token.Is(ImplicationOperator) || token.Is(ImplKeyword))
            return new Implication(first, second);
        if (token.Is(EqualityOperator) || token.Is(EqKeyword))
            return new Equality(first, second);

        if (token.Is(NAndKeyword))
            return new NAnd(first, second);

        Debug.Assert(token.Is(NOrKeyword), "Incorrect token type.");

        return new NOr(first, second);
    }

    private IExpression CreateEqualityOperator(
        in Token token,
        IExpression first,
        IExpression second)
    {
        if (token.Is(EqualOperator))
            return new Equal(first, second);

        Debug.Assert(token.Is(NotEqualOperator), "Incorrect token type.");

        return new NotEqual(first, second);
    }

    private IExpression CreateRelationalOperator(
        in Token token,
        IExpression first,
        IExpression second)
    {
        if (token.Is(LessThanOperator))
            return new LessThan(first, second);
        if (token.Is(LessOrEqualOperator))
            return new LessOrEqual(first, second);
        if (token.Is(GreaterThanOperator))
            return new GreaterThan(first, second);

        Debug.Assert(token.Is(GreaterOrEqualOperator), "Incorrect token type.");

        return new GreaterOrEqual(first, second);
    }

    private IExpression CreateShift(in Token token, IExpression first, IExpression second)
    {
        if (token.Is(LeftShiftOperator))
            return new LeftShift(first, second);

        Debug.Assert(token.Is(RightShiftOperator), "Only '<<', '>>' are allowed here.");

        return new RightShift(first, second);
    }

    private IExpression CreateAddSub(in Token token, IExpression first, IExpression second)
    {
        if (token.Is(PlusOperator))
            return new Add(first, second);

        Debug.Assert(token.Is(MinusOperator), "Only '+', '-' are allowed here.");

        return new Sub(first, second);
    }

    private IExpression CreateMulDivMod(in Token token, IExpression first, IExpression second)
    {
        if (token.Is(MultiplicationOperator))
            return new Mul(first, second);
        if (token.Is(DivisionOperator))
            return new Div(first, second);

        Debug.Assert(token.Is(ModuloOperator) || token.Is(ModKeyword), "Only '*', '/', '%', 'mod' are allowed here.");

        return new Mod(first, second);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Variable CreateVariable(in Token token)
    {
        Debug.Assert(!string.IsNullOrWhiteSpace(token.StringValue), "Id is null.");

        return new Variable(token.StringValue);
    }
}