using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace xFunc.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class CreateFunctionGenerator : IIncrementalGenerator
{
    private const string AttributeName = "FunctionNameAttribute";
    private const string FullyQualifiedAttributeName = $"xFunc.Maths.{AttributeName}";

    private const string Function = """
                // <auto-generated />
                using System.Collections.Immutable;
                using System.Diagnostics;
                using System.Diagnostics.CodeAnalysis;

                namespace xFunc.Maths;

                public partial class Parser
                {
                    [ExcludeFromCodeCoverage]
                    private IExpression CreateFunction(in Token token, ImmutableArray<IExpression> arguments)
                    {
                        Debug.Assert(token.IsId(), "Token should be Id.");
                        Debug.Assert(!string.IsNullOrWhiteSpace(token.StringValue), "Id is empty.");

                        return token.StringValue.ToLowerInvariant() switch
                        {

                """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var functions = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                FullyQualifiedAttributeName,
                static (x, _) => x is ClassDeclarationSyntax,
                Transform)
            .SelectMany((x, _) => x.Names.Select(attr => (Name: attr, NamedTypeSymbol: x.NamedTypeSymbol)))
            .Collect();

        context.RegisterSourceOutput(functions, Generate);
    }

    private static (IEnumerable<string> Names, INamedTypeSymbol NamedTypeSymbol) Transform(
        GeneratorAttributeSyntaxContext syntaxContext,
        CancellationToken cancellationToken)
    {
        var names = syntaxContext.Attributes
            .Where(x => x.AttributeClass?.Name == AttributeName)
            .SelectMany(x => x.ConstructorArguments)
            .Where(x => x is { IsNull: false, Kind: TypedConstantKind.Primitive })
            .Select(x => x.Value)
            .Cast<string>();

        var namedSymbol = syntaxContext.SemanticModel
            .GetDeclaredSymbol(syntaxContext.TargetNode, cancellationToken) as INamedTypeSymbol ?? throw new Exception();

        return (Names: names, NamedTypeSymbol: namedSymbol);
    }

    private static void Generate(
        SourceProductionContext sourceContext,
        ImmutableArray<(string Name, INamedTypeSymbol NamedTypeSymbol)> functions)
    {
        var source = new StringBuilder(Function);

        var dict = new Dictionary<string, string>
        {
            { "IDifferentiator", "differentiator" },
            { "ISimplifier", "simplifier" },
            { "IConverter", "converter" },
            { "ImmutableArray", "arguments" },
        };

        foreach (var function in functions.OrderBy(x => x.Name))
        {
            var functionName = function.Name;
            var namedTypeSymbol = function.NamedTypeSymbol;
            var className = namedTypeSymbol.ToString();
            var ctor = namedTypeSymbol.Constructors
                .FirstOrDefault(x => x.Parameters.Any(p => p.Type.Name == nameof(ImmutableArray)));
            if (ctor is null)
            {
                throw new Exception();
            }

            var arguments = string.Join(", ", ctor.Parameters.Select(x => dict[x.Type.Name]));

            source.AppendLine($"""
                            "{functionName}" => new {className}({arguments}),
                """);
        }

        source.AppendLine("""
                        var id => new UserFunction(id, arguments),
                    };
                }
            }
            """);

        sourceContext.AddSource("Parser.CreateFunction.g", source.ToString());
    }
}